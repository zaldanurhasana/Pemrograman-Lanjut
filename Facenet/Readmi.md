# Analisis Kode Program

## build_embeddings.py
Kode program di atas berfungsi untuk membaca seluruh gambar wajah di dalam folder data/train, mengekstrak embedding FaceNet dari setiap gambar, lalu menyimpannya menjadi dua file X_train.npy dan y_train.npy. Fungsi iter_images() akan memindai setiap subfolder di dalam data/train—di mana nama subfolder dianggap sebagai nama orang (kelas)—dan menghasilkan pasangan (path, cls) berupa lokasi file gambar dan labelnya. Fungsi build_matrix() kemudian memanggil embed_from_path() untuk mengubah setiap gambar menjadi embedding 512 dimensi; embedding yang berhasil dideteksi dimasukkan ke list X, sementara gambarnya dimasukkan ke y sebagai label, dan jika wajah gagal terdeteksi maka file itu dimasukkan ke dalam list bad. Setelah semua gambar diproses, embedding dan label dikonversi menjadi array NumPy dan disimpan ke dua file .npy agar bisa digunakan untuk pelatihan model SVM atau KNN pada tahap berikutnya. Program ini memastikan seluruh foto training diolah secara otomatis dan memberi laporan jumlah embedding yang berhasil dibuat dan berapa yang gagal terdeteksi.

## predict_one.py
Kode program ini digunakan untuk melakukan prediksi identitas wajah menggunakan model KNN yang sebelumnya sudah dilatih, dan disimpan dalam file facenet_knn.joblib. Pertama, program memuat model KNN dengan joblib.load(), lalu fungsi predict_image() menerima path gambar, menampilkan gambar yang sedang diprediksi, dan memanggil embed_from_path() untuk mengekstraksi embedding wajah menggunakan FaceNet. Jika wajah tidak terdeteksi, fungsi memberi pesan gagal. Jika embedding berhasil, model menghitung probabilitas untuk semua kelas menggunakan predict_proba(), kemudian memilih label dengan probabilitas tertinggi melalui np.argmax(). Nilai probabilitas tertinggi menjadi confidence, dan dibandingkan dengan unknown_threshold (default 0.70). Jika confidence di bawah threshold, gambar dianggap UNKNOWN, menandakan bahwa wajah kemungkinan tidak termasuk kelas yang dikenal saat pelatihan. Jika confidence memenuhi ambang batas, program menampilkan label kelas beserta tingkat kepercayaannya. Bagian if __name__ == "__main__": menunjukkan bahwa ketika file dijalankan langsung, fungsi akan memprediksi gambar data/val/Zalda/z1.jpg.

## train_classifier
Kode program ini digunakan untuk melatih model SVM (Support Vector Machine) sebagai klasifier untuk mengenali wajah berdasarkan embedding FaceNet yang telah dibuat sebelumnya. Pertama, program memuat dataset X_train.npy berisi embedding gambar dan y_train.npy berisi label nama orang. Model disusun menggunakan Pipeline, yang terdiri dari dua tahap: StandardScaler untuk menormalisasi data agar setiap dimensi embedding memiliki skala yang seimbang, dan SVC dengan kernel RBF yang bekerja baik pada data non-linear seperti embedding wajah. Parameter C=10 dan gamma="scale" mengatur fleksibilitas hyperplane, sementara probability=True digunakan agar model dapat menghasilkan probabilitas prediksi. Karena data sangat sedikit (kurang dari 5 sampel), cross-validation hanya menggunakan cv=2 untuk menghindari error. Fungsi cross_val_score() menghitung akurasi rata-rata dan standar deviasi model sebelum pelatihan penuh. Setelah itu, model benar-benar dilatih menggunakan clf.fit(X, y) dan disimpan dengan joblib.dump() ke file facenet_svm.joblib, sehingga bisa digunakan pada tahap prediksi selanjutnya.

## train_knn.py
Kode program ini digunakan untuk melatih model KNN (K-Nearest Neighbors) sebagai klasifier untuk mengenali wajah berdasarkan embedding FaceNet. Pertama, program memuat file X_train.npy yang berisi embedding wajah dan y_train.npy yang berisi label identitas masing-masing embedding. Karena dataset wajah kamu sangat kecil (umumnya hanya beberapa foto per orang), KNN menjadi pilihan yang tepat karena bekerja baik pada dataset kecil dan tidak membutuhkan proses pelatihan kompleks. Model dibangun menggunakan Pipeline, dimulai dari StandardScaler untuk menormalkan setiap fitur pada embedding, sehingga jarak antar embedding tidak bias. Kemudian KNeighborsClassifier digunakan dengan n_neighbors=1 dan jarak euclidean, yang berarti model hanya melihat satu tetangga terdekat untuk menentukan identitas wajah. Setelah pipeline dilatih menggunakan clf.fit(X, y), model disimpan ke file facenet_knn.joblib dengan joblib.dump(), sehingga bisa dipakai pada script prediksi wajah. Output akhirnya menandakan bahwa model KNN sukses tersimpan dan siap digunakan.

## utils_facenet.py
Kode ini merupakan modul utama FaceNet yang menangani proses deteksi wajah, alignment, dan pembuatan embedding menggunakan MTCNN dan InceptionResnetV1. Pertama, program menentukan apakah sistem menggunakan GPU (CUDA) atau CPU, lalu menginisialisasi dua komponen penting: MTCNN sebagai pendeteksi dan perapi wajah (alignment), serta InceptionResnetV1 sebagai model FaceNet untuk menghasilkan embedding 512 dimensi. Fungsi read_img_bgr() membaca gambar dalam format BGR menggunakan OpenCV, sementara bgr_to_pil() mengubahnya menjadi format PIL RGB yang dibutuhkan MTCNN. Fungsi face_align() mengambil gambar dan memanfaatkan MTCNN untuk mendeteksi serta mengekstrak wajah dalam ukuran 160×160. Fungsi embed_face_tensor() menerima wajah ter-align sebagai tensor, menambah dimensi batch, lalu memprosesnya melalui model FaceNet untuk menghasilkan embedding numerik. Fungsi embed_from_path() menyatukan seluruh proses: baca gambar → deteksi wajah → buat embedding. Terakhir, fungsi cosine_similarity() digunakan untuk membandingkan dua embedding dengan metode cosine similarity, sehingga bisa menentukan apakah dua wajah memiliki kemiripan atau tidak. Secara keseluruhan, modul ini menjadi fondasi semua tahapan FaceNet: verifikasi wajah, training, prediksi, dan evaluasi.

## verify_pair
Kode ini digunakan untuk melakukan verifikasi wajah 1:1, yaitu membandingkan dua gambar wajah untuk menentukan apakah keduanya berasal dari orang yang sama. Program mengambil dua path gambar (img1 dan img2), lalu menggunakan fungsi embed_from_path() dari modul utils_facenet untuk menghasilkan embedding FaceNet dari masing-masing gambar. Jika salah satu gambar gagal terdeteksi wajahnya, program menampilkan pesan error. Jika kedua embedding berhasil dibuat, program menghitung nilai kemiripan antar embedding menggunakan cosine_similarity(). Nilai similarity ini berupa angka antara -1 sampai 1, di mana semakin mendekati 1 berarti semakin mirip. Kemudian nilai similarity dibandingkan dengan threshold (ambang batas) sebesar 0.85. Jika similarity ≥ 0.85, program menyimpulkan kedua wajah tersebut dianggap match (orang yang sama), jika tidak maka dianggap berbeda. Secara keseluruhan, kode ini adalah implementasi paling dasar dari verifikasi wajah menggunakan FaceNet.
